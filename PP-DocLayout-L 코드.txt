# 사전 설치
# pip install paddlepaddle-gpu==3.0.0 -i https://www.paddlepaddle.org.cn/packages/stable/cu126/
# pip install paddleocr
 
import os
from glob import glob
from paddleocr import LayoutDetection, PPStructureV3
import paddle
from concurrent.futures import ThreadPoolExecutor
 
# -----------------------------
# 환경 설정
# -----------------------------
input_folder = "./input_images"  # 분석할 이미지 폴더
output_folder = "./output"       # 결과 저장 폴더
os.makedirs(output_folder, exist_ok=True)
 
# -----------------------------
# 장치 감지 및 PaddlePaddle 설정
# -----------------------------
device = "gpu" if paddle.is_compiled_with_cuda() else "cpu"
paddle.set_device(device)
print(f"Using device: {device}")
 
# -----------------------------
# 모델 로드
# -----------------------------
layout_model = LayoutDetection(model_name="PP-DocLayout-L")
structure_pipeline = PPStructureV3(layout_detection_model_name="PP-DocLayout-L")
 
# -----------------------------
# 이미지 파일 수집
# -----------------------------
image_extensions = ["*.jpg", "*.jpeg", "*.png", "*.tif", "*.tiff"]
image_paths = []
for ext in image_extensions:
    image_paths.extend(glob(os.path.join(input_folder, ext)))
 
if not image_paths:
    print("분석할 이미지가 없습니다.")
    exit()
 
# -----------------------------
# 이미지 처리 함수
# -----------------------------
def process_image(img_path):
    img_name = os.path.splitext(os.path.basename(img_path))[0]
    print(f"=== Processing: {img_name} ===")
 
    # 레이아웃 탐지
    layout_results = layout_model.predict(img_path, batch_size=1)
    for i, res in enumerate(layout_results):
        res.save_to_img(save_path=os.path.join(output_folder, f"{img_name}_layout_{i+1}.jpg"))
        res.save_to_json(save_path=os.path.join(output_folder, f"{img_name}_layout_{i+1}.json"))
 
    # 문서 구조화 (PP-StructureV3)
    structure_results = structure_pipeline.predict(img_path)
    for i, res in enumerate(structure_results):
        res.save_to_json(save_path=os.path.join(output_folder, f"{img_name}_struct_{i+1}.json"))
        res.save_to_markdown(save_path=os.path.join(output_folder, f"{img_name}_struct_{i+1}.md"))
 
# -----------------------------
# 멀티스레딩으로 이미지 병렬 처리
# -----------------------------
max_workers = min(4, len(image_paths))  # 동시에 처리할 스레드 수
with ThreadPoolExecutor(max_workers=max_workers) as executor:
    executor.map(process_image, image_paths)
 
print("\n모든 이미지 분석 완료. 결과는 output 폴더에 저장됨.")